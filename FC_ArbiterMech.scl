FUNCTION "FC_ArbiterMech" : BOOL
{ S7_Optimized_Access := 'TRUE' }

VAR_INPUT
    LocalManualGlobal : BOOL;

    OwnerReq   : USINT;   // DB_Const.OWNER_*
    OwnerReqId : UINT;

    ReqCmd     : USINT;   // DB_Const.CMD_*
    ReqParam1  : INT;

    ReleaseOwner : BOOL;  // TRUE = звільнити ownership
    LockOnly     : BOOL;  // TRUE = тільки lock/verify, без запису Cmd
END_VAR

VAR_IN_OUT
    M : "UDT_BaseMechanism";
END_VAR

VAR_TEMP
    okOwner   : BOOL;
    isLocal   : BOOL;
    allowExec : BOOL;
END_VAR

BEGIN

    // =========================================================
    // КРИТИЧНА ПЕРЕВІРКА: CMD_SET_FORCE НЕ ПОВИНЕН ЙТИ ЧЕРЕЗ АРБІТР
    // =========================================================
    IF ReqCmd = CMD_SET_FORCE THEN
        // CMD_SET_FORCE обробляється в FC_ManualMechCmdHandler напряму
        // Якщо ми тут - це помилка виклику
        FC_ArbiterMech := FALSE;
        RETURN;
    END_IF;

    // =========================================================
    // БАЗОВА ПЕРЕВІРКА: Слот має бути замаплений
    // =========================================================
    IF (M.DeviceType = TYPE_NONE) OR (M.TypedIndex = UINT#16#FFFF) THEN
        FC_ArbiterMech := FALSE;
        RETURN;
    END_IF;

    allowExec := TRUE;

    // =========================================================
    // LocalManual має вищий пріоритет
    // =========================================================
    isLocal := LocalManualGlobal OR M.LocalManual;
    IF isLocal THEN
        allowExec := FALSE;
    END_IF;

    // =========================================================
    // ReleaseOwner (звільнення ownership)
    // =========================================================
    IF allowExec AND ReleaseOwner THEN
        okOwner := (M.OwnerCur = OwnerReq) AND (M.OwnerCurId = OwnerReqId);

        IF NOT okOwner THEN
            allowExec := FALSE;
        END_IF;

        // =========================================================
        // КРИТИЧНА ПЕРЕВІРКА: Механізм має бути в IDLE
        // =========================================================
        // Заборонено звільняти owner поки механізм працює.
        // Причини:
        //   1. Безпека: механізм завжди має відповідального власника
        //   2. Передбачуваність: release = "я закінчив роботу"
        //   3. Запобігання orphan processes (механізм без owner)
        //
        // Правильний workflow:
        //   1. CMD_START → механізм працює
        //   2. CMD_STOP → чекаємо STS_IDLE
        //   3. CMD_RELEASE_OWNER → тепер можна звільнити
        // =========================================================
        IF allowExec AND (M.Status <> STS_IDLE) THEN
            allowExec := FALSE;
        END_IF;

        IF allowExec THEN
            M.OwnerCur   := OWNER_NONE;
            M.OwnerCurId := 0;
        END_IF;

    // =========================================================
    // LockOnly or Command (захват owner та/або виконання команди)
    // =========================================================
    ELSIF allowExec THEN

        // Захват owner (якщо він вільний)
        IF (M.OwnerCur = OWNER_NONE)
           AND (OwnerReq <> OWNER_NONE) THEN
            M.OwnerCur   := OwnerReq;
            M.OwnerCurId := OwnerReqId;
        END_IF;

        // Перевірка ownership
        okOwner := (M.OwnerCur = OwnerReq) AND (M.OwnerCurId = OwnerReqId);
        IF NOT okOwner THEN
            allowExec := FALSE;
        END_IF;

        // Виконання команди (якщо не LockOnly)
        IF allowExec AND (NOT LockOnly) THEN
            IF ReqCmd = CMD_NONE THEN
                allowExec := FALSE;
            END_IF;

            IF allowExec THEN
                M.Cmd        := ReqCmd;
                M.CmdParam1  := ReqParam1;
            END_IF;
        END_IF;

    END_IF;

    FC_ArbiterMech := allowExec;

END_FUNCTION
