FUNCTION "FC_Redler" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      R : "UDT_Redler";   // // Типізований редлер (I/O + таймінги)
      B : "UDT_BaseMechanism";   // // Базовий механізм слоту (Cmd/Status/FLT/Owner..
   END_VAR

   VAR_TEMP 
      startTimeout : Bool;
      speedTimeout : Bool;
      elapsedMs : DInt;
      nowTck : DInt;
      forceBreaker : Bool;
      forceOverflow : Bool;
      forceSpeed : Bool;
      isFault : Bool;
      isBlocked : Bool;
   END_VAR


BEGIN
	// ============================================================================
	// FC_Redler (Refactored to CASE)
	// ============================================================================
	
	REGION "Стани та формування"
	    // BIT0 (1)  - подавити FLT_OVERFLOW
	    // BIT1 (2)  - подавити FLT_BREAKER
	    // BIT2 (4)  - подавити FLT_SPEED (не стартує / втрата швидкості)
	    #forceOverflow := (#B.Force_Code AND 1) <> 0;
	    #forceBreaker := (#B.Force_Code AND 2) <> 0;
	    #forceSpeed := (#B.Force_Code AND 4) <> 0;
	END_REGION
	
	REGION "1) RESET та лач FAULT"
	    IF #B.Cmd = "CMD_RESET" THEN
	        #B.FLTCode := "FLT_NONE";
	        #B.Status := "STS_IDLE";
	        #R.StartMs := 0;
	        #R.SpeedLostMs := 0;
	        #B.LastCmd := #B.Cmd;
	    END_IF;
	    
	    #isFault := (#B.Status = "STS_FAULT");
	END_REGION
	
	REGION "2) Передумови керування (Enable / Ручний)"
	    IF NOT #B.Enable_OK THEN
	        #B.Status := "STS_DISABLED";
	        #B.OwnerCur := 0;
	        #B.OwnerCurId := 0;
	        #R.StartMs := 0;
	        #R.SpeedLostMs := 0;
	    ELSIF #B.LocalManual THEN
	        #B.Status := "STS_LOCAL";
	        #B.OwnerCur := 0;
	        #B.OwnerCurId := 0;
	        #R.StartMs := 0;
	        #R.SpeedLostMs := 0;
	    END_IF;
	    
	    #isBlocked := (#B.Status = "STS_DISABLED") OR (#B.Status = "STS_LOCAL");
	END_REGION
	
	REGION "3) Фіксація останньої команди"
	    IF #B.Cmd <> "CMD_NONE" THEN
	        #B.LastCmd := #B.Cmd;
	    END_IF;
	END_REGION
	
	REGION "4) Місцеві аварії"
	    IF (NOT #isFault) AND (NOT #isBlocked) THEN
	        // Пріоритет аварій: BREAKER > OVERFLOW
	        IF (NOT #R.DI_Breaker_OK) AND (NOT #forceBreaker) THEN
	            #B.FLTCode := "FLT_BREAKER";
	            #B.Status := "STS_FAULT";
	        ELSIF (NOT #R.DI_Overflow_OK) AND (NOT #forceOverflow) THEN
	            #B.FLTCode := "FLT_OVERFLOW";
	            #B.Status := "STS_FAULT";
	        END_IF;
	        #isFault := (#B.Status = "STS_FAULT");
	    END_IF;
	END_REGION
	
	REGION "5 & 6) Машина станів та обробка команд"
	    IF (NOT #isFault) AND (NOT #isBlocked) THEN
	        
	        CASE #B.Status OF
	                
	            "STS_IDLE":
	                IF #B.Cmd = "CMD_START" THEN
	                    #B.Status := "STS_STARTING";
	                    #R.StartMs := TIME_TCK();
	                END_IF;
	                
	            "STS_STARTING":
	                // Контроль розгону (набору швидкості)
	                IF #R.DI_Speed_OK OR #forceSpeed THEN
	                    #B.Status := "STS_RUNNING";
	                    #R.SpeedLostMs := 0;
	                ELSE
	                    #startTimeout := "FC_TimeElapsedMs"(
	                                                        StartTck := #R.StartMs,
	                                                        TimeoutMs := "TimeoutMs_Redler_Start",
	                                                        ElapsedMs => #elapsedMs,
	                                                        NowTck => #nowTck
	                    );
	                    IF #startTimeout THEN
	                        #B.FLTCode := "FLT_NO_RUNFB";
	                        #B.Status := "STS_FAULT";
	                        #isFault := TRUE;
	                    END_IF;
	                END_IF;
	                
	                IF #B.Cmd = "CMD_STOP" THEN
	                    #B.Status := "STS_STOPPING";
	                END_IF;
	                
	            "STS_RUNNING":
	                // Контроль втрати швидкості з фільтром часу (SpeedPause)
	                IF #R.DI_Speed_OK OR #forceSpeed THEN
	                    #R.SpeedLostMs := 0;
	                ELSE
	                    IF #R.SpeedLostMs = 0 THEN
	                        #R.SpeedLostMs := TIME_TCK();
	                    END_IF;
	                    
	                    #speedTimeout := "FC_TimeElapsedMs"(
	                                                        StartTck := #R.SpeedLostMs,
	                                                        TimeoutMs := "TimeoutMs_Redler_SpeedPause",
	                                                        ElapsedMs => #elapsedMs,
	                                                        NowTck => #nowTck
	                    );
	                    
	                    IF #speedTimeout THEN
	                        #B.FLTCode := "FLT_NO_RUNFB";
	                        #B.Status := "STS_FAULT";
	                        #isFault := TRUE;
	                    END_IF;
	                END_IF;
	                
	                IF #B.Cmd = "CMD_STOP" THEN
	                    #B.Status := "STS_STOPPING";
	                END_IF;
	                
	            "STS_STOPPING":
	                // Чекаємо зупинки датчика швидкості
	                IF (NOT #R.DI_Speed_OK) THEN
	                    #B.Status := "STS_IDLE";
	                    #R.StartMs := 0;
	                    #R.SpeedLostMs := 0;
	                END_IF;
	                
	            ELSE
	                #B.Status := "STS_IDLE";
	        END_CASE;
	        
	    END_IF;
	END_REGION
	
	
	REGION "7) Формування виходу DO_Run"
	    // DO_Run — похідний від фінального Status.
	    // У FAULT / DISABLED / LOCAL -> FALSE автоматично.
	    IF (#B.Status =  "STS_STARTING") OR (#B.Status =  "STS_RUNNING") THEN
	        #R.DO_Run := TRUE;
	    ELSE
	        #R.DO_Run := FALSE;
	    END_IF;
	END_REGION
	
END_FUNCTION

